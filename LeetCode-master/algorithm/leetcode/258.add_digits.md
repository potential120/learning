## 每周算法 - 1

> 258.各位相加 —— leetcode

### 信息卡片

- 时间： 2019-11-18
- 题目链接：https://leetcode-cn.com/problems/add-digits/
- tag：
    - math

题目描述：

给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。

示例:
```
输入: 38
输出: 2 
解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。```
```


### 参考答案
时间复杂度为O(1)的解法：

除个位外，每一位上的值都是通过(9+1)进位的过程得到的，想一下拨算盘进位

把整数n看成n样物品，原本是以10个1份打包的，现在从这些10个1份打包好的里面，拿出1个，让它们以9个为1份打包。

这样就出现了两部分的东西：
- 原本10个现在9个1份的，打包好的物品，这些，我们不用管
- 零散的物品，它们还可以分成：
  - 从原来打包的里面拿出来的物品，它们的总和 =》 原来打包好的份数 =》 10进制进位的次数 =》 10进制下，除个位外其他位上的值的总和
  - 以10个为1份打包时，打不进去的零散物品 =》 10进制个位上的值

如上零散物品的总数，就是第一次处理num后得到的累加值

如果这个累加值>9，那么如题就还需要将各个位上的值再相加，直到结果为个位数为止。也就意味着还需要来一遍如上的过程。

那么按照如上的思路，似乎可以通过n % 9得到最后的值

但是有1个关键的问题，如果num是9的倍数，那么就不适用上述逻辑。原本我是想得到n被打包成10个1份的份数+打不进10个1份的散落个数的和。通过与9取模，去获得那个不能整除的1，作为计算份数的方式，但是如果可以被9整除，我就无法得到那个1，也得不到个位上的数。

所以需要做一下特殊处理，(num - 1) % 9 + 1

可以这么做的原因：原本可以被完美分成9个为一份的n样物品，我故意去掉一个，那么就又可以回到上述逻辑中去得到我要的n被打包成10个一份的份数+打不进10个一份的散落个数的和。而这个减去的1就相当于从，在10个1份打包的时候散落的个数中借走的，本来就不影响原来10个1份打包的份数，先拿走再放回来，都只影响散落的个数，所以没有关系。

- 作者：liveforexperience
- 链接：https://leetcode-cn.com/problems/add-digits/solution/java-o1jie-fa-de-ge-ren-li-jie-by-liveforexperienc/

```java
class Solution {
    public int addDigits(int num) {
        return (num - 1) % 9 + 1;
    }
}
```


### 其他优秀解答

@wangxun-Jack 

```java
class Solution {
    public int addDigits(int number) {
        int divisor = 1; //除数
        String strValue = Integer.toString(number);
        int len = strValue.length(); //位数

        if (1 == len) {
            return number;
        }

        for (int i = 1; i <= (len - 1); i++) {
            divisor = divisor * 10;
        }

        int sum = 0; //求和
        int consult;
        int remainder;
        int tmp = number;

        do {
            consult = tmp / divisor; //商
            remainder = tmp % divisor; //余数
            divisor = divisor / 10;
            sum = sum + consult;
            tmp = remainder;
        } while (0 != remainder);

        sum = addDigits(sum);

        return sum;
    }
}

```

@muggleCY 

自己最开始的做法
```javascript
var addDigits = function(num) {
    var num1 = 0;
    var num2 = 0;
    while (num > 9) {
        num1 = num % 10;
        num2 += num1;
        num = Math.floor(num / 10);
        if (num < 10) {
            num += num2;
            num2 = 0;
        }
    }
    return num;
};
```
结合对于一般整数来说直接对整数进行对9求余，便可得到小于10的结果。除非整除另外考虑
```javascript
var addDigits = function(num) {
    if (num == 0) {
        return 0;
    }
    var i = num % 9;
    if (i == 0) {
        return 9;
    } else {
        return i;
    }
};
```